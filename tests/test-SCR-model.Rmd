---
title: "Test SemiCompRisks model.Rmd"
author: "Jacqueline Buros"
date: "June 1, 2016"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r prep-data, echo = FALSE, eval = TRUE, results = 'hide'}
root_dir <- path.expand('../')
function_dir <- root_dir
stanfile_dir <- file.path(root_dir, 'stanfiles')
suppressMessages(suppressWarnings({
  library(dplyr)
  library(ggplot2)
  library(rstan)
  library(purrr)
  library(deSolve)
  library(lme4)
  library(arm)
  source(file.path(function_dir, 'simulate-data.function.R'), chdir = T)
  source(file.path(function_dir, 'prep-data.function.R'), chdir = T)
  source(file.path(function_dir, 'make-data-plots.function.R'), chdir = T)
  rstan_options(auto_write = TRUE)
  options(mc.cores = min(parallel::detectCores(),3))
}))
```

The goal of this analysis is to simulate data according to a tumor-immunity growth model and evaluate a potential biomarker in the context of a semi-competing-risks analysis. 

The tumor-immunity growth model is described in the following files:

   1. [test-growth-model.md](test-growth-model.md)
   2. [test-generative-model-cmdstan.md](test-generative-model.md)

Here the potential biomarker we are evaluating is the "initial tumor size". We know it is informative to the simulated data, but we do not have a direct correlation of this measure vs clinical events. 

## Simulate data

As in previous examples, we will simulate data using the `simulate_data` function.

For consistency, we will use the same simulation routines used in the Survival Analysis example.

```{r sim-data}
data <- simulate_data(n = 100
                      , max_size = 4000
                      , max_t = 50
                      , failure_threshold = 4
                      , progression_threshold = 3
                      )

## prep data for analysis
res <- prep_data(data) 
survd <- res$per_patient ## summarized per patient; appropriate for typical survival analysis
adata <- res$per_observation ## denormalized; appropriate for longitudinal analysis
rm(res)

## review data for a few simulated points
plot_simulated_data(data, n = 6)
```

## Evaluate using SemiCompRisks

```{r run-semi-comp-risks}
library(SemiCompRisks)
library(dplyr)
set.seed(1234)

Y <- survd %>% 
  dplyr::select(first_progression, progression_status, first_failure, failure_status) %>%
  dplyr::mutate(progression_status = ifelse(first_progression == first_failure, 0, 1))
  
## cluster <- sample_data %>% dplyr::select(cluster)
form1 <- as.formula( ~ rescaled_init_size)
form2 <- as.formula( ~ rescaled_init_size)
form3 <- as.formula( ~ rescaled_init_size)
lin.pred <- list(form1, form2, form3)
```

SemiCompRisks has a number of hyperparameters & tuning params that need to be set in order for this to run effectively. Here we borrow heavily from the documentation.

```{r set-hyperparams}

#####################
## Hyperparameters ##
#####################
## Subject-specific frailty variance component
## - prior parameters for 1/theta
##
theta.ab <- c(0.7, 0.7)

## PEM baseline hazard function
##
PEM.ab1 <- c(0.7, 0.7) # prior parameters for 1/sigma_1^2
PEM.ab2 <- c(0.7, 0.7) # prior parameters for 1/sigma_2^2
PEM.ab3 <- c(0.7, 0.7) # prior parameters for 1/sigma_3^2
##
PEM.alpha1 <- 10 # prior parameters for K1
PEM.alpha2 <- 10 # prior parameters for K2
PEM.alpha3 <- 10 # prior parameters for K3


## list to be passed to the BayesID function call
hyperParams <- list(theta=theta.ab,
                    WB=list(),
                    PEM=list(PEM.ab1=PEM.ab1,
                             PEM.ab2=PEM.ab2, 
                             PEM.ab3=PEM.ab3,
                             PEM.alpha1=PEM.alpha1, 
                             PEM.alpha2=PEM.alpha2, 
                             PEM.alpha3=PEM.alpha3
                             ),
                    MVN=list(),
                    DPM=list()
                    )

###################
## MCMC SETTINGS ##
###################
## Setting for the overall run
##
numReps <- 2000
thin <- 10
burninPerc <- 0.5

## Settings for storage
##
nGam_save <- 0          ## nGam_save, the number of Î³ to be stored
storeV <- rep(TRUE, 3)  ## whether to store posterior samples from 3 submodels

## Tuning parameters for specific updates
##
## - common to all models
mhProp_theta_var <- 0.05
mhProp_Vg_var <- c(0.05, 0.05, 0.05)

##
## - specific to the PEM specification of the baseline hazard functions
Cg <- c(0.2, 0.2, 0.2)        ## sum should be <= 0.6
delPertg <- c(0.5, 0.5, 0.5)  ## perterbation parameter 
rj.scheme <- 1 #  If rj.scheme=1, the birth update will draw the proposal time split from 1 : smax. 
               #  If rj.scheme=2, the birth update will draw the proposal time split from uniquely ordered failure times in the data.
Kg_max <- c(50, 50, 50)  ## the maximum number of splits allowed at each iteration in MHG algorithm for PEM models
sg_max <- c(
  ## max time to event for submodel 1 (progression only)
  max(Y$first_progression[Y$progression_status == 1]) 
  
  ## max time submodel 2 (death no progression or death at progression)
  , max(Y$first_failure[Y$first_progression == Y$first_failure])
  
  ## max time submodel 3 (death following progression)
  , max(Y$first_failure[Y$progression_status == 1 & Y$failure_status == 1]) 
)

time_lambda1 <- seq(1, sg_max[1], 1) # timepoints at which h1 events are calculated
time_lambda2 <- seq(1, sg_max[2], 1) # timepoints at which h2 events are calculated
time_lambda3 <- seq(1, sg_max[3], 1) # timepoints at which h3 events are calculated

##
mcmc.PEM <- list(run=list(numReps=numReps
                          , thin=thin
                          , burninPerc=burninPerc
                          )
                 , storage=list(nGam_save=nGam_save
                                , storeV=storeV
                                )
                 , tuning=list(mhProp_theta_var=mhProp_theta_var
                               , mhProp_Vg_var=mhProp_Vg_var
                               , Cg=Cg
                               , delPertg=delPertg
                               , rj.scheme=rj.scheme
                               , Kg_max=Kg_max
                               , time_lambda1=time_lambda1 
                               , time_lambda2=time_lambda2
                               , time_lambda3=time_lambda3
                               )
                 )
```

Now, we can execute the model

```{r execute-pem-scr}
##
myModel <- c("Markov", "PEM")
myPath <- "Output/02-Results-PEM/"
startValues <- vector("list", 2)
startValues[[1]] <- initiate.startValues(as.matrix(Y), lin.pred, survd, model=myModel)
startValues[[2]] <- initiate.startValues(as.matrix(Y), lin.pred, survd, model=myModel, theta = 0.23)
##
fit_PEM <- BayesID(as.matrix(Y), lin.pred, survd, cluster=NULL, model=myModel, hyperParams, startValues, mcmc.PEM, path=myPath)
fit_PEM
summ.fit_PEM <- summary(fit_PEM); names(summ.fit_PEM)
summ.fit_PEM
```
