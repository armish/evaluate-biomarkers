---
title: "Test SemiCompRisks model.Rmd"
author: "Jacqueline Buros"
date: "June 1, 2016"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r prep-data, echo = FALSE, eval = TRUE, results = 'hide'}
root_dir <- path.expand('../')
function_dir <- root_dir
stanfile_dir <- file.path(root_dir, 'stanfiles')
suppressMessages(suppressWarnings({
  library(dplyr)
  library(ggplot2)
  library(rstan)
  library(purrr)
  library(deSolve)
  library(lme4)
  library(arm)
  source(file.path(function_dir, 'format-data-semicomprisks.function.R'), chdir = T)
  source(file.path(function_dir, 'simulate-data.function.R'), chdir = T)
  source(file.path(function_dir, 'prep-data.function.R'), chdir = T)
  source(file.path(function_dir, 'make-data-plots.function.R'), chdir = T)
  set.seed(1234)
  rstan_options(auto_write = TRUE)
  options(mc.cores = min(parallel::detectCores(),3))
}))
```

The goal of this analysis is to simulate data according to a tumor-immunity growth model and evaluate a potential biomarker in the context of a semi-competing-risks analysis. 

The tumor-immunity growth model is described in the following files:

   1. [test-growth-model.md](test-growth-model.md)
   2. [test-generative-model-cmdstan.md](test-generative-model.md)

Here the potential biomarker we are evaluating is the "initial tumor size". We know it is informative to the simulated data, but we do not have a direct correlation of this measure vs clinical events. 

## Simulate data

As in previous examples, we will simulate data using the `simulate_data` function.

For consistency, we will use the same simulation routines used in the Survival Analysis example.

```{r sim-data}
data <- simulate_data(n = 100
                      , max_size = 4000
                      , max_t = 50
                      , failure_threshold = 4
                      , progression_threshold = 3
                      )

## prep data for analysis
res <- prep_data(data) 
survd <- res$per_patient ## summarized per patient; appropriate for typical survival analysis
adata <- res$per_observation ## denormalized; appropriate for longitudinal analysis
rm(res)

## review data for a few simulated points
plot_simulated_data(data, n = 6)
```

## Evaluate using SemiCompRisks

```{r run-semi-comp-risks}
library(SemiCompRisks)
library(dplyr)
set.seed(1234)

Y <- survd %>% 
  dplyr::select(first_progression, progression_status, first_failure, failure_status) %>%
  dplyr::mutate(progression_status = ifelse(first_progression == first_failure, 0, 1))
  
## cluster <- sample_data %>% dplyr::select(cluster)
form1 <- as.formula( ~ rescaled_init_size)
form2 <- as.formula( ~ rescaled_init_size)
form3 <- as.formula( ~ rescaled_init_size)
lin.pred <- list(form1, form2, form3)
```

SemiCompRisks has a number of hyperparameters & tuning params that need to be set in order for this to run effectively. Here we borrow heavily from the documentation.

```{r set-hyperparams}

#####################
## Hyperparameters ##
#####################
## Subject-specific frailty variance component
## - prior parameters for 1/theta
##
theta.ab <- c(0.7, 0.7)

## PEM baseline hazard function
##
PEM.ab1 <- c(0.7, 0.7) # prior parameters for 1/sigma_1^2
PEM.ab2 <- c(0.7, 0.7) # prior parameters for 1/sigma_2^2
PEM.ab3 <- c(0.7, 0.7) # prior parameters for 1/sigma_3^2
##
PEM.alpha1 <- 10 # prior parameters for K1
PEM.alpha2 <- 10 # prior parameters for K2
PEM.alpha3 <- 10 # prior parameters for K3


## list to be passed to the BayesID function call
hyperParams <- list(theta=theta.ab,
                    WB=list(),
                    PEM=list(PEM.ab1=PEM.ab1,
                             PEM.ab2=PEM.ab2, 
                             PEM.ab3=PEM.ab3,
                             PEM.alpha1=PEM.alpha1, 
                             PEM.alpha2=PEM.alpha2, 
                             PEM.alpha3=PEM.alpha3
                             ),
                    MVN=list(),
                    DPM=list()
                    )

###################
## MCMC SETTINGS ##
###################
## Setting for the overall run
##
numReps <- 2000
thin <- 10
burninPerc <- 0.5

## Settings for storage
##
nGam_save <- 0          ## nGam_save, the number of Î³ to be stored
storeV <- rep(TRUE, 3)  ## whether to store posterior samples from 3 submodels

## Tuning parameters for specific updates
##
## - common to all models
mhProp_theta_var <- 0.05
mhProp_Vg_var <- c(0.05, 0.05, 0.05)

##
## - specific to the PEM specification of the baseline hazard functions
Cg <- c(0.2, 0.2, 0.2)        ## sum should be <= 0.6
delPertg <- c(0.5, 0.5, 0.5)  ## perterbation parameter 
rj.scheme <- 1 #  If rj.scheme=1, the birth update will draw the proposal time split from 1 : smax. 
               #  If rj.scheme=2, the birth update will draw the proposal time split from uniquely ordered failure times in the data.
Kg_max <- c(50, 50, 50)  ## the maximum number of splits allowed at each iteration in MHG algorithm for PEM models
sg_max <- c(
  ## max time to event for submodel 1 (progression only)
  max(Y$first_progression[Y$progression_status == 1]) 
  
  ## max time submodel 2 (death no progression or death at progression)
  , max(Y$first_failure[Y$progression_status == 0 & Y$failure_status == 1])
  
  ## max time submodel 3 (death following progression)
  , max(Y$first_failure[Y$progression_status == 1 & Y$failure_status == 1]) 
)

time_lambda1 <- seq(1, sg_max[1], 1) # timepoints at which h1 events are calculated
time_lambda2 <- seq(1, sg_max[2], 1) # timepoints at which h2 events are calculated
time_lambda3 <- seq(1, sg_max[3], 1) # timepoints at which h3 events are calculated

##
mcmc.PEM <- list(run=list(numReps=numReps
                          , thin=thin
                          , burninPerc=burninPerc
                          )
                 , storage=list(nGam_save=nGam_save
                                , storeV=storeV
                                )
                 , tuning=list(mhProp_theta_var=mhProp_theta_var
                               , mhProp_Vg_var=mhProp_Vg_var
                               , Cg=Cg
                               , delPertg=delPertg
                               , rj.scheme=rj.scheme
                               , Kg_max=Kg_max
                               , time_lambda1=time_lambda1 
                               , time_lambda2=time_lambda2
                               , time_lambda3=time_lambda3
                               )
                 )
```

Now, we can execute the model & summarize results

```{r execute-pem-scr}
##
myModel <- c("Markov", "PEM")
myPath <- "Output/02-Results-PEM/"
startValues <- vector("list", 2)
startValues[[1]] <- initiate.startValues(as.matrix(Y), lin.pred, survd, model=myModel)
startValues[[2]] <- initiate.startValues(as.matrix(Y), lin.pred, survd, model=myModel, theta = 0.23)
##
fit_PEM <- BayesID(as.matrix(Y), lin.pred, survd, cluster=NULL, model=myModel, hyperParams, startValues, mcmc.PEM, path=myPath)
fit_PEM
summ.fit_PEM <- summary(fit_PEM); names(summ.fit_PEM)
summ.fit_PEM
```

Plot baseline hazard estimated by model

```{r plot-baseline-hazard}
plot(fit_PEM, plot.est = 'BH')
```

Plot range of coefficient estimates for each submodel

```{r plot-coefs}

scr_res <- data.frame(
  beta1 =
    fit_PEM %>% 
    map('beta1.p') %>%
    compact() %>%
    flatten_dbl()
  , beta2 =
    fit_PEM %>% 
    map('beta2.p') %>%
    compact() %>%
    flatten_dbl()
  , beta3 =
    fit_PEM %>% 
    map('beta3.p') %>%
    compact() %>%
    flatten_dbl()
) %>%
  tidyr::gather(submodel, coef)

scr_res %>%
  dplyr::mutate(submodel = ifelse(submodel == 'beta1','h1: non-terminating illness'
                                  , ifelse(submodel == 'beta2', 'h2: terminating event prior to illness'
                                           , 'h3: terminating event following illness'))) %>%
  ggplot(., aes(x = coef, group = submodel, colour = submodel)) + 
  geom_density() + facet_wrap(~submodel, ncol = 1)

```

## summarize probability that coef <> 0

```{r summarize-coefs}

scr_res %>%
  dplyr::mutate(submodel = ifelse(submodel == 'beta1','h1: non-terminating illness'
                                  , ifelse(submodel == 'beta2', 'h2: terminating event prior to illness'
                                           , 'h3: terminating event following illness'))) %>%
  group_by(submodel) %>%
  dplyr::summarize(prop_above_0 = mean(ifelse(coef > 0, 1, 0))
                   , prop_below_0 = mean(ifelse(coef < 0, 1, 0))
                   ) %>%
  ungroup() %>%
  dplyr::mutate(proportion_not_zero = ifelse(prop_above_0 > prop_below_0, prop_below_0, prop_above_0))

```

## compare to analysis using Survival -> failure 

```{r survival-analysis1}
survfit1 <- coxph(
  formula = Surv(first_failure, failure_status) ~ rescaled_init_size
  , data = survd
  )

ss1 <- summary(survfit1)
ss1
```


## compare to analysis using Survival -> progression

```{r survival-analysis1}
survfit2 <- coxph(
  formula = Surv(first_progression, progression_status) ~ rescaled_init_size
  , data = survd
  )

ss2 <- summary(survfit2)
ss2
```

## compare to analysis using Survival -> progression or failure 

```{r survival-analysis1}
survfit3 <- coxph(
  formula = Surv(first_failure_or_progression, failure_or_progression_status) ~ rescaled_init_size
  , data = survd
  )

ss3 <- summary(survfit3)
ss3
```

## compare to semi-competing-risks model developed using Stan

```{r semi-comp-risks-stan}

stand <- format_data_semicomprisks(data = survd, time_precision = 1)
standata <- list(
  ## dimensions
  N = nrow(stand)
  , S = n_distinct(stand$subject_id)
  , T = n_distinct(stand$timepoint_id)
  , X = 1 ## number of covars
  
  ## data 
  , s_id = stand$subject_id
  , t_id = stand$timepoint_id
  , t_dur = stand$duration
  , t_time = stand$time_to
  , ev1 = stand$progression
  , ev2 = stand$failure
  , post_ev1 = stand$post_progression
  , x = stand %>% dplyr::select(rescaled_init_size)
  
  # which covariates inform which model 
  , x1 = array(1, dim = c(1))
  , x2 = array(1, dim = c(1))  
  , x3 = array(1, dim = c(1))  
)

testfit <- stan(
  file = file.path(stanfile_dir, 'semi_competing_risks_model.stan')
  , data = standata
  , chains = 1
  , iter = 10
  , control = list(adapt_delta = 0.95)
)

stanfit <- stan(
  fit = testfit
  , data = standata
  , chains = 3
  , iter = 800
  , control = list(adapt_delta = 0.95)
  )
```
